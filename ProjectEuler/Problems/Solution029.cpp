// https://projecteuler.net/problem=29
/*
Distinct powers

Consider all integer combinations of ab for 2 <= a <= 5 and 2 <= b <= 5:

2^2=4,	2^3=8,	 2^4=16,  2^5=32
3^2=9,	3^3=27,  3^4=81,  3^5=243
4^2=16, 4^3=64,  4^4=256, 4^5=1024
5^2=25, 5^3=125, 5^4=625, 5^5=3125
If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by ab for 2 <= a <= 100 and 2 <= b <= 100 ?

Solution:
*/

#include <iostream>
#include <cmath>
#include <vector>
#include <bitset>
using namespace std;
typedef unsigned long long natural;

natural GCD(natural u, natural v) {
	int shift;
	if (u == 0) return v;
	if (v == 0) return u;

	for (shift = 0; ((u | v) & 1) == 0; ++shift) {
		u >>= 1;
		v >>= 1;
	}

	while ((u & 1) == 0)
		u >>= 1;

	do {
		while ((v & 1) == 0)
			v >>= 1;
		if (u > v) {
			natural t = v;
			v = u;
			u = t;
		}
		v = v - u;
	} while (v != 0);

	return u << shift;
}

int main() {
	const natural n = 100;
	natural sqrtN = sqrt(n);
	natural maxPower = (natural)(log(n) / log(2));
	
	vector<natural> dupPerPower(maxPower + 1, 0);
	bitset<n + 1> overlapping;
	for (natural i = 2; i <= maxPower; i++) {
		overlapping.reset();
		for (natural j = 1; j <= i - 1; j++) {
			natural spacing = j / GCD(j, i);
			for (natural k = 0; k <= j*n/i; k += spacing)
				overlapping.set(k);
		}
		overlapping.reset(0);
		overlapping.reset(1);
		dupPerPower[i] = overlapping.count();
	}

	vector<natural> numPowers(maxPower + 1, 0);
	vector<bool> repeated(sqrtN + 1, false);
	for (natural i = 2; i <= sqrtN; i++) {
		if (!repeated[i]) {
			for (natural p = 2, ip = i*i; ip <= n; p++, ip *= i) {
				numPowers[p]++;
				if (ip <= sqrtN)
					repeated[ip] = true;
			}
		}
	}

	natural total = (n - 1)*(n - 1);
	for (natural p = 2; p <= maxPower; p++)
		total -= numPowers[p] * dupPerPower[p];
	cout << total << endl;
}